<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>什么是分布式锁及其应用场景 · Hexo</title><meta name="description" content="分布式锁有哪些应用场景和实现？电商网站都会遇到秒杀，特价之类的活动，大促活动有一个共同特点就是访问量激增，在高并发下会出现成千上万人抢购一个商品的情景，虽然在系统设计时会通过限流、异步、排队等方式优化，但整体的并发还是平时的数倍以上，参加活动的商品一般都是限量库存，如何防止库存超卖，避免并发问题呢？"><meta name="keywords" content="极限博客,极限Blog,博客,极限"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/mrcore"><i class="fa fa-github"></i></a></li><li><a href="mailto:x@jixian.io"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>什么是分布式锁及其应用场景</a></h3></div><div class="post-content"><h4 id="分布式锁有哪些应用场景和实现？"><a href="#分布式锁有哪些应用场景和实现？" class="headerlink" title="分布式锁有哪些应用场景和实现？"></a>分布式锁有哪些应用场景和实现？</h4><p>电商网站都会遇到秒杀，特价之类的活动，大促活动有一个共同特点就是访问量激增，在高并发下会出现成千上万人抢购一个商品的情景，虽然在系统设计时会通过限流、异步、排队等方式优化，但整体的并发还是平时的数倍以上，参加活动的商品一般都是限量库存，如何防止库存超卖，避免并发问题呢？分布式锁便是一个解决方案。</p>
<h4 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h4><p>我们都知道，在业务开发中，为了保证在多线程下处理共享数据的安全性，需要保证同一时刻只有一个线程能处理共享数据。</p>
<p>Java语言给我们提供了线程锁，开放了处理锁机制的API，比如Synchronized、Lock等。当一个锁被某个线程池有的时候，另一个线程尝试去获取这个锁就会失败或者阻塞，知道持有锁的线程释放了该锁。</p>
<p>在单台服务器的内部，可以通过线程加锁的方式来同步，避免并发问题，那么分布式场景下呢？</p>
<p><img src="%5Cimage%5C2020-05-18%5CCgqCHl6z34CAWUxoAAE1hnZz5gE051.png" alt="CgqCHl6z34CAWUxoAAE1hnZz5gE051"></p>
<p>分布式场景下解决并发问题，需要应用分布式所记述，如上图所示，分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求用一个方法或者用一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>
<h4 id="分布式锁的常用实现"><a href="#分布式锁的常用实现" class="headerlink" title="分布式锁的常用实现"></a>分布式锁的常用实现</h4><p>实现分布式锁目前有三种流行方案，即基于数据库、Redis、Zookeeper的方案。</p>
<h4 id="分布式锁应该具备的条件"><a href="#分布式锁应该具备的条件" class="headerlink" title="分布式锁应该具备的条件"></a>分布式锁应该具备的条件</h4><ul>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li>
<li>高可用的获取锁与释放锁</li>
<li>高性能的获取锁与释放锁</li>
<li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ul>
<h5 id="基于关系型数据库"><a href="#基于关系型数据库" class="headerlink" title="基于关系型数据库"></a>基于关系型数据库</h5><p>基于关系型数据库实现分布式锁，是依赖数据库的唯一性老师先资源锁定，比如主键和唯一索引等，以唯一索引为例，创建一张锁表，定义防范或者资源名，失效时间等字段，同时针对枷锁的信息唯一索引，比如方法名，当要锁住某个方法或资源时，就再该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放所的时候就删除这条记录。</p>
<p>基于这个方法有以下例子：</p>
<p>下面先创建一张基于数据库的分布式锁表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;methodLock&#96; (</span><br><span class="line">&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">&#96;method_name&#96; varchar(64) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;锁定的方法或者资源&#39;,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">UNIQUE KEY &#96;uidx_method_name&#96; (&#96;method_name &#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;对方法加锁&#39;;</span><br></pre></td></tr></table></figure>

<p>当希望对某个方法加锁时，执行以下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into methodLock(method_name) values (&#39;method_name&#39;);</span><br></pre></td></tr></table></figure>

<p>在数据库表定义中，我们对method_name做了唯一性约束，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么就可以认为操作成功的那个线程获得了该方法的锁，可以执行后面的业务逻辑。</p>
<p>当方法执行完毕以后，想要释放锁的话，在数据库中删除对应的记录即可。</p>
<p>基于数据库实现分布式锁操作简单，但是并不是一个可以落地的方案，有很多地方需要优化。</p>
<p><strong>存在单点故障的风险</strong></p>
<p>数据库实现方式强依赖数据库的可用性，一旦数据库挂掉，则会导致业务系统不可用，为了解决这个问题，需要配置数据库主从机器，防止单点故障。</p>
<p><strong>超时无法失效</strong></p>
<p>如果一旦解锁操作失败，则会导致所记录一直在数据库中，其他线程无法再获得锁，解决这个问题，可以添加独立的定时任务，通过时间戳对比等方式，删除超时数据。</p>
<p><strong>不可重入</strong></p>
<p>可重入性是锁的一个重要特性，以Java语言为例，常见的Synchronize、Lock等都支持可重入，在数据库实现方式中，同一个线程在没有释放锁之前无法再次获得该锁，因为数据已经存在，再次插入就会失败，实现可重入，需要改造加锁方法，额外存储和判断线程信息，不阻塞获得锁的线程再次请求加锁。</p>
<p><strong>无法实现阻塞</strong></p>
<p>其他线程在请求对应方法时，插入数据失败会直接返回，不会阻塞线程，如果需要阻塞其他线程，需要不断地重试insert操作，知道数据插入成功，这个操作是服务器和数据库资源的极大浪费。</p>
<p>可以看到，借助数据库实现一个完备的分布式锁，存在很多问题，并且读写数据库需要一定的性能，可能会影响业务执行的耗时。</p>
<h4 id="应用Redis缓存"><a href="#应用Redis缓存" class="headerlink" title="应用Redis缓存"></a>应用Redis缓存</h4><p>相比基于数据库实现分布式锁，缓存的性能更好，并且各种缓存组件也提供了多种集群方案，可以解决单点问题。</p>
<p>常见的开源缓存组件吗都支持分布式锁，包括Redis、Memcached及Tair。以常见的Redis为例，应用Redis实现分布式锁，最直接的想法是利用setnx和expire命令实现加锁。</p>
<p>在Redis中，setnx如果不存在，则SET的意思，当一个线程执行setnx返回1，说明key不存在，该线程获得锁；当一个线程执行setnx放回0.说明key已经存在，那么获取所失败，expire就是给锁加一个过期时间。</p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(setnx(key,value)&#x3D;&#x3D;1)&#123;</span><br><span class="line">     expire(key,expireTime)</span><br><span class="line">     try&#123;</span><br><span class="line">        &#x2F;&#x2F;业务处理</span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">       &#x2F;&#x2F;释放锁</span><br><span class="line">       del(key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用setnx和expire有一个问题，这两条命令可能不会同时失败，不具备原子性，如果一个线程在执行完setnx之后突然崩溃，道之所没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取，为了解决这个问题，在Redis2.8版本中，添加了SETEX命令，SETEX支持setnx和expire指令组合的原子操作，解决了加锁过程中失败的问题。</p>
<h4 id="基于Zookeeper实现"><a href="#基于Zookeeper实现" class="headerlink" title="基于Zookeeper实现"></a>基于Zookeeper实现</h4><p>Zookeeper有四种节点类型，包括持久节点，持久顺序节点，临时节点和临时顺序节点，利用Zookeeper支持临时顺序节点的特性，可以事先分布式锁。</p>
<p>当客户端对某个方法加锁时，在Zookeeper中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。</p>
<p><img src="%5Cimage%5C2020-05-18%5CCgqCHl6z34-ALXWpAAEiUjbLEMc631.png" alt="CgqCHl6z34-ALXWpAAEiUjbLEMc631"></p>
<p>判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。</p>
<p>下面描述使用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：</p>
<p>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；<br>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；<br>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；<br>完成业务流程后，删除对应的子节点，释放分布式锁。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a1ebab8ce78a">什么是分布式锁</a></p>
<p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=69#/content">分布式技术原理与实战45讲》-蒋越</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-08-09</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Technology-blog/" title="Technology blog">Technology blog </a><a class="tag" href="/tags/技术笔记/" title="技术笔记">技术笔记 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://yoursite.com/2020/08/09/2020-5-18-Distributed lock/,Hexo,什么是分布式锁及其应用场景,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/08/09/2020-5-19-Redis%20lock/" title="分布式锁的正确实现方式">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/08/09/2020-5-13-TCC/" title="TCC事务">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>