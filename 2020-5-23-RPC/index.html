<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>RPC远程服务调用 · David Cai</title><meta name="description" content="总结RPC远程服务调用相关的知识点
RPC远程服务调用是分布式架构的基础，无轮微服务设计上层如何发展，讨论服务治理都绕不开远程服务调用，那么如何理解RPC、有哪些常见的RPC框架，实现一款RPC框架需要哪些技术呢？
如何理解RPCRPC（Remote Procedure Call）是一种进程间通信方"><meta name="keywords" content="大大卫的博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">David Cai</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/David-banana"><i class="fa fa-github"></i></a></li><li><a href="caidaweigo@163.com"><i class="fa fa-envelope"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2019 - 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>RPC远程服务调用</a></h3></div><div class="post-content"><p>总结RPC远程服务调用相关的知识点</p>
<p>RPC远程服务调用是分布式架构的基础，无轮微服务设计上层如何发展，讨论服务治理都绕不开远程服务调用，那么如何理解RPC、有哪些常见的RPC框架，实现一款RPC框架需要哪些技术呢？</p>
<h4 id="如何理解RPC"><a href="#如何理解RPC" class="headerlink" title="如何理解RPC"></a>如何理解RPC</h4><p>RPC（Remote Procedure Call）是一种进程间通信方式，百科给出的定义是这样的：RPC（远程过程调用协议），是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p>RPC允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节，即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。</p>
<p>比如两台服务器A、B，一个应用部署在A服务器上，想要调用B服务器上提供的函数或者方法，由于不在一个内存空间，则不能直接调用，这时候就可以应用RPC来解决</p>
<p><strong>example</strong></p>
<ul>
<li>本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。</li>
<li>远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？</li>
</ul>
<p>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</p>
<p>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</p>
<p> 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。<br> 总结一下上述过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端 </span></span><br><span class="line"><span class="comment">//    Student student = Call(ServerAddr, addAge, student)</span></span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。</span><br><span class="line"><span class="number">2.</span> 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端</span></span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class="line"><span class="number">2.</span> 等待服务端请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在callIdMap中查找，得到相应的函数指针</span><br><span class="line"><span class="number">5.</span> 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>

<p><img src="/2020-5-23-RPC/7632302-ca0ba3118f4ef4fb.png" alt="7632302-ca0ba3118f4ef4fb"></p>
<h4 id="RPC如何实现"><a href="#RPC如何实现" class="headerlink" title="RPC如何实现"></a>RPC如何实现</h4><p>早期的远程服务调用一般是通过RMI或Hessian等工具实现，以Java RMI为例，RMI是Java语言中RPC的一种实现方式。</p>
<p>Java RMI（Java 远程方法调用，Java Remote Method Invocation）是Java变成语言里，一种用于实现远程过程调用的应用程序编程接口，应用Java RMI，可以让某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上的方法。</p>
<p>Java RMI实现主要依赖java.rmi包下面的工具类，具体流程包括继承Remote实现远程接口，开发业务逻辑，创建Server并且注册远程对象，客户端创建Client调用远程方法等，关于RMI的实现细节，由于实际开发中很少应用，这里不展开讲解了。</p>
<p>以Java RMI 为代表的早期RPC实现起来比较繁琐，需要在代码直接编码地址，并且不支持服务治理，比如无法对服务调用进行统计、无法梳理服务依赖情况，无法保证服务上下线是的稳定性等。随着分布式系统规模的增长，传统方式已经无法满足开发需求，于是诞生了一系列的RPC服务框架。</p>
<h4 id="RPC框架代表"><a href="#RPC框架代表" class="headerlink" title="RPC框架代表"></a>RPC框架代表</h4><p>开源社区里有许多优秀的RPC框架，比如常用的Dubbo、Thrift、gRPC等，下面简单介绍这几款组件。</p>
<h4 id="Apache-Dubbo"><a href="#Apache-Dubbo" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h4><p>Dubbo是阿里巴巴公司开源的一个高性能Java分布式服务框架，目前已经称为Apache顶级项目。Dubbo可以通过高性能的RPC实现服务的输出和输入。</p>
<p>Dubbo在设计中采用了微内核架构，基于对Java SPI 机制的扩展实现，Dubbo对分布式服务调用核心功能都开放了扩展点，包括服务调用的负载均衡策略、序列化协议、传输协议，使用者都可以添加自定义实现。</p>
<p>Dubbo 在国内曾经拥有很高的人气，是微服务架构的首选，后来随着 Spring Cloud 的流行，社区一度停更，外部用户发布了 DubboX 等升级版本。最近，Dubbo 社区又重新活跃，更新后的 Dubbo 也发布了 3.0 预览版等，并且宣布会在未来的版本中支持更多特性，值得期待。</p>
<p>Google的gRPC</p>
<p>gRPC是Google开发的高性能、通用的开源RPC框架，gRPC使用ProtoBuf来定义服务，ProtoBuf是Google开发的一种数据序列化协议，性能比较高，压缩和传输效率高，语法也比较简单，另外，gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。</p>
<h4 id="Apache-Thrift"><a href="#Apache-Thrift" class="headerlink" title="Apache Thrift"></a>Apache Thrift</h4><p>Thrift 起源于 Facebook，和 Dubbo 一样，后来被提交 Apache 基金会将 Thrift 作为一个开源项目。Facebook 创造 Thrift 的目的是为了解决 Facebook 各系统间大数据量的传输通信，以及系统间语言环境不同需要跨平台的问题。</p>
<p>Thrift 支持多种编程语言，如 Java、C++、Python、PHP、Ruby 等，可以在多种不同的语言之间通信。应用 Thrift，需要在一个语言无关的 IDL 文件里，定义数据类型和服务接口，然后生成用来构建 RPC 客户和服务器所需的代码。</p>
<p>Thrift 主要的优点是跨语言；缺点是，由于需要定义独立的 IDL 文件，如果对服务进行修改，当数据结构发生变化时，必须重新编辑 IDL 文件、重新编译和生成相关的代码，修改起来比较繁琐。</p>
<h4 id="微博-Motan"><a href="#微博-Motan" class="headerlink" title="微博 Motan"></a>微博 Motan</h4><p>Motan 是新浪微博开源的一个 Java RPC 框架，官方文档对外宣传在微博平台已经广泛应用，每天为数百个服务完成近千亿次的调用。</p>
<p>Motan 基于 Java 语言开发，设计和实现与 Dubbo 比较类似，包括服务提供者（RPC Server）、服务调用方（RPC Client）、服务注册中心（Registry）三个角色。服务端会向注册中心注册服务，消费端使用服务需要先向注册中心进行订阅，根据注册中心的返回列表与具体的 服务端建立连接，进行 RPC 通讯。当服务端发生变更的时候，注册中心也会同步变更，然后同步的通知到消费端。</p>
<p>Motan 也提供了服务治理的功能，包括服务的发现、服务的摘除、高可用及负载均衡。</p>
<h4 id="RPC框架用到哪些技术"><a href="#RPC框架用到哪些技术" class="headerlink" title="RPC框架用到哪些技术"></a>RPC框架用到哪些技术</h4><p>了解了常见的RPC框架后，我们来看下实现一个RPC框架需要哪些技术。</p>
<h4 id="如何建立通信"><a href="#如何建立通信" class="headerlink" title="如何建立通信"></a>如何建立通信</h4><p>实现分布式服务框架，首先要解决不同节点之间通讯的问题，需要在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。</p>
<p>一般来说，建立通信可以使用成熟的网络通信框架，比如 Java 语言中的 Netty，这是一个优秀的网络通信框架。在 Dubbo、Motan 中都应用了 Netty。</p>
<h4 id="如何进行网络传输"><a href="#如何进行网络传输" class="headerlink" title="如何进行网络传输"></a>如何进行网络传输</h4><p>建立通信之后，节点之间数据传输采用什么协议，也就是选择什么样的二进制数据格式组织；传输的数据如何序列化和反序列化，比如在 Dubbo 中，传输协议默认使用 Dubbo 协议，序列化支持选择 Hessian、Kryo、Protobuf 等不同方式。</p>
<h4 id="如何进行服务注册和被发现"><a href="#如何进行服务注册和被发现" class="headerlink" title="如何进行服务注册和被发现"></a>如何进行服务注册和被发现</h4><p>服务注册和发现，也就是服务寻址，以 Dubbo 为例，下图分布式服务典型的寻址和调用过程<img src="/2020-5-23-RPC/CgqCHl6-XeSAaqlXAAE2pEPLeB0026.png" alt="CgqCHl6-XeSAaqlXAAE2pEPLeB0026">服务注册，需要服务提供者启动后主动把服务注册到注册中心，注册中心存储了该服务的 IP、端口、调用方式（协议、序列化方式）等信息。</p>
<p>服务发现，当服务消费者第一次调用服务时，会通过注册中心找到相应的服务提供方地址列表，并缓存到本地，以供后续使用。当消费者再次调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从 IP 列表中取一个服务提供者调用服务。</p>
<p>上面列举了一些分布式服务框架的实现要点，除了这些，还有很多技术细节，比如如何实现服务调用，RPC 框架如何和服务层交互，Java 中通过代理实现服务调用，那么代理对象如何解析请求参数、如何处理返回值等。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/9395659.html">Redis分布式锁的正确实现方式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7d6853140e13">什么是RPC？</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-05-23</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Technology-blog/" title="Technology blog">Technology blog </a><a class="tag" href="/tags/技术笔记/" title="技术笔记">技术笔记 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://yoursite.com/2020-5-23-RPC/,David Cai,RPC远程服务调用,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020-5-27-%E9%AC%BC%E7%81%AD%E4%B9%8B%E5%88%83/" title="鬼灭完结">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020-5-19-Redis%20lock/" title="分布式锁的正确实现方式">下一篇</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"position":"left","width":225,"height":450},"mobile":{"show":true},"react":{"opacity":1}});</script></body></html>