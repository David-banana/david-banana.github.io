<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>分布式调用跟踪 · David Cai</title><meta name="description" content="分布式调用跟踪分布式服务拆分以后，系统变得日趋复杂，业务的调用链也越来越长，如何快速定位线上故障，就需要依赖分布式调用跟踪技术。
为什么需要分布式调用跟踪随着分布式服务架构的流行，特别是微服务等设计理念在系统中的应用，系统架构变得越来越分散。

可以看到，随着服务的拆分，系统的模块变得越来越多，不同"><meta name="keywords" content="大大卫的博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">David Cai</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/David-banana"><i class="fa fa-github"></i></a></li><li><a href="caidaweigo@163.com"><i class="fa fa-envelope"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2019 - 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>分布式调用跟踪</a></h3></div><div class="post-content"><h4 id="分布式调用跟踪"><a href="#分布式调用跟踪" class="headerlink" title="分布式调用跟踪"></a>分布式调用跟踪</h4><p>分布式服务拆分以后，系统变得日趋复杂，业务的调用链也越来越长，如何快速定位线上故障，就需要依赖分布式调用跟踪技术。</p>
<h4 id="为什么需要分布式调用跟踪"><a href="#为什么需要分布式调用跟踪" class="headerlink" title="为什么需要分布式调用跟踪"></a>为什么需要分布式调用跟踪</h4><p>随着分布式服务架构的流行，特别是微服务等设计理念在系统中的应用，系统架构变得越来越分散。</p>
<p><img src="/2020-6-1-Distributed%20call%20tracing/CgqCHl7M6YaAdXpcAAF2ShT9Ssc825.png" alt="CgqCHl7M6YaAdXpcAAF2ShT9Ssc825"></p>
<p>可以看到，随着服务的拆分，系统的模块变得越来越多，不同的模块可能由不同的团队维护，一个请求可能会涉及到几十个服务的协同处理，牵制到多个团队的业务系统。</p>
<p>假设现在某次服务调用失败，或者出现请求超时，需要定位具体是哪个服务引起的异常，哪个环节导致的超时，就需要去每个服务里查看日志，这样的处理效率是非常低的。</p>
<p>另外，系统拆分以后，缺乏一个自上而下全局的调用ID，如何有效的进行相关的数据分析工作呢？比如电商的活动的转化率，购买率，广告系统的点击链路等。如果没有一个统一的调用ID来记录，只依靠业务上的主键等是很难实现的，特别是对于一些大型网站系统，如淘宝、京东等，这些问题尤其突出。</p>
<h4 id="分布式调用跟踪业务场景"><a href="#分布式调用跟踪业务场景" class="headerlink" title="分布式调用跟踪业务场景"></a>分布式调用跟踪业务场景</h4><p>分布式调用跟踪技术就是解决上面的业务问题，即通过调用链的方式，把一次请求调用过程完整的串联起来，这样就实现了对请求的调用路径的监控。</p>
<p>分布式调用链就是讲一次分布式请求还原成调用链路，显式的在后端查看一次分布式式请求的调用情况，比如各个节点上的耗时，请求具体达到了哪台机器上，每个服务节点的请求状态等。</p>
<p>一般来说，分布式调用跟踪可以应用在以下的场景中。</p>
<ul>
<li><strong>故障的快速定位</strong>：通过调用链跟踪，一次请求的逻辑轨迹可以完整清晰的展示出来，在开发的过程中，可以在业务日志中添加调用链ID,还可以通过调用链结合业务日志快速定位错误信息。</li>
<li><strong>各个调用环节的性能分析</strong>：在调用链的各个环节分别添加调用时延，并分析系统的性能瓶颈，进行针对性的优化。</li>
<li><strong>各个调用环节的可用性，持久层依赖等</strong>:通过分析各个环节的平均时延，QPS等信息，可以找到系统的薄弱环节，对一些模块做出调整，比如数据冗余等。</li>
<li><strong>数据分析</strong>：调用链是一条完整的业务日志，可以得到用户的行为路径，并汇总分析</li>
</ul>
<h4 id="分布式调用跟踪实现原理"><a href="#分布式调用跟踪实现原理" class="headerlink" title="分布式调用跟踪实现原理"></a>分布式调用跟踪实现原理</h4><p>分布式链路跟踪技术实现，主要是参考Google和Dapper论文，分布式调用是一种全链路日志，主要的设计基于Span日志格式，下面简单介绍这个日志结构。</p>
<p>Dapper用Span来表示一个服务调用开始和结束的时间，也就是时间区间，并记录了Span的名称以及每个Span的ID和父ID，如果一个Span没有父ID则被称之为Root Span。</p>
<p>一个请求到达应用后所调用的所有服务，以及所有服务组件组成的调用链就像是一个树结构，追踪这个调用链路得到的树结构称之为Trace，所有的Span都挂在一个特定的Trace上，公用一个TraceId。</p>
<p><img src="/2020-6-1-Distributed%20call%20tracing/CgqCHl7M6aGALudMAAG903WelvM769.png" alt="CgqCHl7M6aGALudMAAG903WelvM769"></p>
<p>在一次 Trace 中，每个服务的每一次调用，就是一个 Span，每一个 Span 都有一个 ID 作为唯一标识。同样，每一次 Trace 都会生成一个 TraceId 在 Span 中作为追踪标识，另外再通过一个 parentSpanId，标明本次调用的发起者。</p>
<p>当 Span 有了上面三个标识后，就可以很清晰地将多个 Span 进行梳理串联，最终归纳出一条完整的跟踪链路。</p>
<p>确定了日志格式以后，接下来日志如何采集和解析，日志的采集和存储有许多开源的工具可以选择。一般来说，会使用离线 + 实时的方式去存储日志，主要是分布式日志采集的方式，典型的解决方案如 Flume 结合 Kafka 等 MQ，日志存储到 HBase 等存储中，接下来就可以根据需要进行相关的展示和分析。</p>
<h4 id="分布式调用跟踪的选型"><a href="#分布式调用跟踪的选型" class="headerlink" title="分布式调用跟踪的选型"></a>分布式调用跟踪的选型</h4><p>大的互联网公司都有自己的分布式跟踪系统，比如前面介绍的 Google 的 Dapper、Twitter 的 Zipkin、淘宝的鹰眼等。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=69#/detail/pc?id=1913">分布式技术原理与实战45讲</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-01</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Technology-blog/" title="Technology blog">Technology blog </a><a class="tag" href="/tags/技术笔记/" title="技术笔记">技术笔记 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://yoursite.com/2020-6-1-Distributed call tracing/,David Cai,分布式调用跟踪,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020-6-9-graduate1.0/" title="毕业照1.0！">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020-5-31-%E5%89%91%E7%81%B5/" title="剑灵">下一篇</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>